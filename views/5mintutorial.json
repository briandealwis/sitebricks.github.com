{"id":"5mintutorial","title":"5 Minute Tutorial","html":"<p></p>  \n<p>Get a feel for Sitebricks Sitebricks if you have 5 minutes to spare!</p> \n<h2>Responding to HTTP events</h2> \n<p>When a request comes in, you generally want to do some preparing in code before rendering a response. For example, you may retrieve information stored in a database. If we were trying to display a list of movies, this is exactly what we would want:</p> \n<p> </p> \n<ul>\n  @Repeat(items=movies, var=&quot;movie&quot;) \n <li>${movie.name}</li> \n</ul>  \n<p>This template simply renders from a collection <code>movies</code> to an unordered html list (<code>&lt;ul&gt;</code>). On any HTTP GET (most requests are these), let's say you want to load the list of movies from a data store:</p> \n<pre><code>@At(&quot;/movies&quot;)\npublic class MovieList {\n  private List&lt;Movie&gt; movies;\n\n  @Get\n  public void get() {\n      this.movies = ... ;   //load from db\n  }\n\n  // getter for movies\n}\n</code></pre> \n<p>Method annotation <code>@Get</code> tells Sitebricks to use this method as an event handler for all HTTP GET requests to the <code>/movies</code> page. The method <code>get()</code> is called prior to any rendering being done, so you have the opportunity to prepare the list of of movies.</p> \n<h2>Mapping to pretty URLs</h2> \n<p>Sometimes called &quot;restful&quot; URLs, the practice of constructing a resource name with everything as a path item is increasingly very popular. For example, rather than <code>/app/movieList.html?name=Godfather</code> you would use <code>/movie/Godfather</code> and specify the content type (HTML) in subsumed headers.</p> \n<p>Sitebricks supports and encourages this scheme, not the least because it is more readable and concise:</p> \n<pre><code>@At(&quot;/movie/:name&quot;)\npublic class MovieDetails { .. }\n</code></pre> \n<p>The colon-prefixed part of a path will be treated as dynamic and any value is accepted. All of:</p> \n<ul> \n <li><code>/movie/Godfather</code></li> \n <li><code>/movie/AClockworkOrange</code></li> \n <li><code>/movie/Superman</code></li> \n</ul> \n<p>...will be dispatched to the <code>MovieDetails</code> page (shown above). Now if you want to do any preparing before rendering the movie's details (like fetching it from a data store) you can do it with a restful event handler:</p> \n<pre><code>@At(&quot;/movie/:name&quot;)\npublic class MovieDetails { \n  private Movie movie;\n\n  @Get\n  public void get(@Named(&quot;name&quot;) String movieTitle) { \n      this.movie = ... ;    //fetch based on 'movieTitle'\n  }\n}\n</code></pre> \n<p>The portion of the URI after <code>/movie/</code> is extracted and provided as a parameter to method <code>get()</code>. Use Guice's <code>@Named</code> annotation to indicate which URI-part you are interested in.</p> \n<p>You can, of course map multiple parts this way:</p> \n<pre><code>@At(&quot;/music/:artist/songs/:song&quot;)\npublic class SongsPage { \n\n  @Get\n  public void get(@Named(&quot;song&quot;) String song, @Named(&quot;artist&quot;) String artist) { .. }\n  ...\n}\n</code></pre> \n<p>And this would match any of: * <code>/music/nirvana/songs/teen-spirit</code> * <code>/music/pearljam/songs/even-flow</code> <br /> * <code>/music/muse/songs/newborn</code></p> \n<h2>Responding to Form POSTs</h2> \n<p>Reading resources (like movies or song details) over HTTP typically happens with the GET request. The converse of GET, writing resources, happens using the POST request. This is typically triggered when an HTML form is filled out and <em>submitted</em>. Let's say we wanted to do just that with a blog entry:</p> \n<p><em>NewBlog.html</em></p> \n<pre><code>&lt;html&gt;\n&lt;body&gt;\n  &lt;form action=&quot;/blogs&quot; method=&quot;post&quot;&gt;\n      &lt;input name=&quot;newBlog.subject&quot; type=&quot;text&quot;/&gt;\n      &lt;textarea name=&quot;newBlog.text&quot; rows=&quot;10&quot; cols=&quot;40&quot;/&gt;\n\n      &lt;input type=&quot;submit&quot; value=&quot;post entry&quot;/&gt;\n  &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> \n<p>This is a normal HTML form and has three interesting characteristics:</p> \n<ul> \n <li>We send the data via a POST (<code>method=&quot;post&quot;</code>) to page <code>/blogs</code>, which represents the collection of blogs</li> \n <li>We have two fields named <code>newBlog.subject</code> and <code>newBlog.text</code> respectively</li> \n <li><p>These fields will map to properties on our page class as shown below</p> <p>@At(&quot;/blogs&quot;) public class Blogs { private Blog newBlog = new Blog();</p> <p> @Post public void postEntry() { ...save(newBlog); //save 'newBlog' to some data store }</p> <p> // get + set method for newBlog }</p></li> \n</ul> \n<p>That's it! The fact that you specified the property paths in the form (<code>newBlog.subject</code> and <code>newBlog.text</code>) means that when method <code>postEntry()</code> is called (due to the <code>@Post</code> annotation), the values from the form fields are already bound to the <code>newBlog</code> object.</p> \n<p>You can also have a <em>normal</em> action for <code>/blogs</code> backed by a GET method which simply displays the list of blogs, this can coexist with the POST handler we just added:</p> \n<pre><code>@At(&quot;/blogs&quot;)\npublic class Blogs {\n  private Blog newBlog = new Blog();\n  private List&lt;Blog&gt; blogs;\n\n  @Post\n  public void postEntry() { .. }\n\n  @Get\n  public void listBlogs() {\n      this.blogs = .. ;     //fetch from store\n  }\n\n  // get + set methods\n}\n</code></pre> \n<p>And <code>Blog</code> is a simple data model object with two fields:</p> \n<pre><code>public class Blog {\n  private String subject;\n  private String text;\n\n  //get + set methods\n}\n</code></pre> \n<p>Now, POSTing will result in nothing being displayed, since the <code>List&lt;Blog&gt; blogs</code> is only loaded in the GET handler method <code>listBlogs()</code>. One way to mitigate this is to add the same functionality in <code>postEntry()</code> (or simply invoke <code>listBlogs()</code> from it). </p> \n<p>However, this is a bit clunky and may not always suit your intention. For example, you may wish to redirect to another page (as per the post-and-redirect pattern) after posting an entry. This is easy to do from the POST handler (or any handler) by returning a <code>String</code>:</p> \n<pre><code>@At(&quot;/blogs&quot;)\npublic class Blogs {\n  ...\n\n  @Post\n  public String postEntry() { \n       ...save(newBlog);\n\n       return &quot;/blogs&quot;;     //redirect to '/blogs' as a GET\n  }\n\n  @Get \n  public void listBlogs() { .. }\n}\n</code></pre> \n<p>You may return any string so long as it can be sent as a valid URI redirect. For example:</p> \n<ul> \n <li><code>/movies/clerks</code></li> \n <li><code>http://wideplay.com</code></li> \n <li><code>12</code></li> \n</ul> \n<p>.. are all valid redirections (assuming of course, that they are valid destinations).</p>","postedOn":"06 Jun 2011"}